
### **Verificación:**
```bash
gcc --version
```

### **Programa Básico:**
```c
#include <stdio.h>
int main() {
    printf("Hola, mundo\n");
    return 0;
}
```

##  **2. FUNDAMENTOS DE C**

### **Tipos de Datos:**
```c
int entero = 10;
float flotante = 3.14f;
char caracter = 'A';
double doble = 3.1415926535;
```

### **Estructuras de Control:**
```c
// Condicional
if (condicion) {
} else if (otra_condicion) {
} else {
}

// Bucles
for (int i = 0; i < 10; i++) {
}
while (condicion) {
}
do {
} while (condicion);
```

### **Funciones:**
```c
int suma(int a, int b) {
    return a + b;
}

void incrementar(int *x) {
    (*x)++;
}
```

##  **3. PUNTEROS Y MEMORIA DINÁMICA**

### **Punteros Básicos:**
```c
int x = 10;
int *p = &x;        // p apunta a x
printf("%d", *p);   // Accede al valor
*p = 20;            // Modifica x
```

### **Gestión de Memoria:**
```c
// Asignación
int *arr = malloc(10 * sizeof(int));
int *arr2 = calloc(10, sizeof(int));  // Inicializado a 0

// Redimensionar
arr = realloc(arr, 20 * sizeof(int));

// Liberar
free(arr);
arr = NULL;
```

### **Aritmética de Punteros:**
```c
int arr[] = {10, 20, 30, 40};
int *p = arr;
printf("%d", *p);       // 10
printf("%d", *(p+1));   // 20
printf("%d", *(p+2));   // 30
```

##  **4. RECURSIVIDAD**

### **Concepto Básico:**
```c
int factorial(int n) {
    if (n == 0) return 1;           // Caso base
    else return n * factorial(n-1); // Caso recursivo
}
```

### **Búsqueda Binaria Recursiva:**
```c
int binarySearch(int arr[], int inicio, int fin, int clave) {
    if (inicio > fin) return -1;
    int medio = (inicio + fin) / 2;
    if (arr[medio] == clave) return medio;
    else if (clave < arr[medio]) 
        return binarySearch(arr, inicio, medio-1, clave);
    else 
        return binarySearch(arr, medio+1, fin, clave);
}
```

##  **5. ALGORITMOS DE ORDENAMIENTO**

### **Básicos (O(n²)):**

#### **Bubble Sort:**
```c
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```

#### **Insertion Sort:**
```c
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int clave = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > clave) {
            arr[j+1] = arr[j];
            j--;
        }
        arr[j+1] = clave;
    }
}
```

### **Eficientes (O(n log n)):**

#### **Quicksort:**
```c
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int p = partition(arr, low, high);
        quickSort(arr, low, p-1);
        quickSort(arr, p+1, high);
    }
}
```

#### **Merge Sort:**
```c
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid+1, right);
        merge(arr, left, mid, right);
    }
}
```

#### **Heap Sort:**
```c
void heapSort(int arr[], int n) {
    for (int i = n/2-1; i >= 0; i--)
        heapify(arr, n, i);
    for (int i = n-1; i > 0; i--) {
        swap(&arr[0], &arr[i]);
        heapify(arr, i, 0);
    }
}
```

### **Búsqueda Binaria:**
```c
int binarySearch(int arr[], int n, int target) {
    int inicio = 0, fin = n-1;
    while (inicio <= fin) {
        int medio = (inicio + fin) / 2;
        if (arr[medio] == target) return medio;
        else if (arr[medio] < target) inicio = medio+1;
        else fin = medio-1;
    }
    return -1;
}
```

##  **6. ESTRUCTURAS DE DATOS**

### **Lista Enlazada Simple:**
```c
typedef struct Nodo {
    int dato;
    struct Nodo *siguiente;
} Nodo;

Nodo* crearNodo(int dato) {
    Nodo* nuevo = (Nodo*)malloc(sizeof(Nodo));
    nuevo->dato = dato;
    nuevo->siguiente = NULL;
    return nuevo;
}

void insertarInicio(Nodo** cabeza, int dato) {
    Nodo* nuevo = crearNodo(dato);
    nuevo->siguiente = *cabeza;
    *cabeza = nuevo;
}
```

### **Pila (LIFO):**
```c
typedef struct Pila {
    Nodo* tope;
} Pila;

void push(Pila* pila, int dato) {
    Nodo* nuevo = crearNodo(dato);
    nuevo->siguiente = pila->tope;
    pila->tope = nuevo;
}

int pop(Pila* pila) {
    if (pila->tope == NULL) return -1;
    Nodo* temp = pila->tope;
    int dato = temp->dato;
    pila->tope = pila->tope->siguiente;
    free(temp);
    return dato;
}
```

### **Cola (FIFO):**
```c
typedef struct Cola {
    Nodo* frente;
    Nodo* final;
} Cola;

void encolar(Cola* cola, int dato) {
    Nodo* nuevo = crearNodo(dato);
    if (cola->final == NULL) {
        cola->frente = cola->final = nuevo;
    } else {
        cola->final->siguiente = nuevo;
        cola->final = nuevo;
    }
}

int desencolar(Cola* cola) {
    if (cola->frente == NULL) return -1;
    Nodo* temp = cola->frente;
    int dato = temp->dato;
    cola->frente = cola->frente->siguiente;
    if (cola->frente == NULL) cola->final = NULL;
    free(temp);
    return dato;
}
```




##  **8. APLICACIONES PRÁCTICAS**

### **Pilas:**
- Deshacer/Rehacer en editores
- Evaluación de expresiones
- Llamadas a funciones (call stack)
- Navegación web (historial)

### **Colas:**
- Gestión de procesos en SO
- Impresión de documentos
- Simulación de filas de espera
- Búsqueda en amplitud (BFS)

### **Listas Enlazadas:**
- Implementación de pilas/colas
- Tablas hash con encadenamiento
- Listas de reproducción
- Navegación en aplicaciones



### **Buenas Prácticas:**
```c
//  Verificar siempre malloc
int *arr = malloc(n * sizeof(int));
if (arr == NULL) {
    printf("Error de memoria\n");
    return;
}

//  Inicializar punteros
int *p = NULL;

//  Liberar y poner a NULL
free(arr);
arr = NULL;

//  Usar typedef para estructuras
typedef struct Nodo {
    int dato;
    struct Nodo *siguiente;
} Nodo;
```



